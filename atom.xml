<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Amit Kapadia</title>
 <link href="http://kapadia.github.io/atom.xml" rel="self"/>
 <link href="http://kapadia.github.io"/>
 <updated>2013-09-13T09:53:34-05:00</updated>
 <id>http://kapadia.github.io</id>
 <author>
   <name>Amit Kapadia</name>
 </author>

 
 <entry>
   <title>Emscripten: Pointers and Pointers</title>
   <link href="http://kapadia.github.io/emscripten/2013/09/13/emscripten-pointers-and-pointers.html"/>
   <updated>2013-09-13T00:00:00-05:00</updated>
   <id>http://kapadia.github.io/emscripten/2013/09/13/emscripten-pointers-and-pointers</id>
   <content type="html">&lt;p&gt;&lt;a href='http://emscripten.org'&gt;Emscripten&lt;/a&gt; is a &lt;a href='http://www.mozilla.org/research/'&gt;Mozilla Research&lt;/a&gt; project that compiles LLVM bytecode to Javascript. Any language (e.g. C and C++) that compiles to LLVM as an intermediary may be ported to Javascript for use in the browser. This is a brief write up on porting functions to JS and exposing their functionality.&lt;/p&gt;

&lt;h3 id='c_to_javascript'&gt;C to Javascript&lt;/h3&gt;

&lt;p&gt;Porting functions from C/C++ to Javascript is straight-forward. As an example, the C function below multiplies two numbers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extern &amp;quot;C&amp;quot; {
  int float_multiply(float x, float y) {
    return x * y;
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running the following on the command line will port this function to Javascript outputting the code to &lt;code&gt;multiply.js&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emcc multiply.cpp -o multiply.js -s EXPORTED_FUNCTIONS=&amp;quot;[&amp;#39;_float_multiply&amp;#39;]&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the &lt;code&gt;EXPORTED_FUNCTIONS&lt;/code&gt; flag specifies an array of functions to export, each with a leading underscore. If the function is not explicitly listed then Emscripten will consider it dead code, and strip it from the output.&lt;/p&gt;

&lt;p&gt;After including &lt;code&gt;multiply.js&lt;/code&gt; in a project, the function may be accessed by calling &lt;code&gt;cwrap&lt;/code&gt; from &lt;code&gt;Module&lt;/code&gt;, an object that Emscripten defines in its output. This function exposes &lt;code&gt;float_multiply&lt;/code&gt; by specifying the function name, the return type, and an array of argument types.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var float_multiply = Module.cwrap(&amp;#39;float_multiply&amp;#39;, &amp;#39;number&amp;#39;, [&amp;#39;number&amp;#39;, &amp;#39;number&amp;#39;]);
var result = float_multiply(5.2, 4.5);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using &lt;code&gt;cwrap&lt;/code&gt; (or &lt;code&gt;ccall&lt;/code&gt;) is simple when functions use only primitive types as arguments, however many interesting functions use pointers as a means to operate over an array.&lt;/p&gt;

&lt;h3 id='pointers'&gt;Pointers&lt;/h3&gt;

&lt;p&gt;Using pointers with a ported function needs a bit more machinery. For example, the C function below is ported using &lt;code&gt;emcc&lt;/code&gt; in the same way as &lt;code&gt;float_multiply&lt;/code&gt;, but it&amp;#8217;s slightly more complex to use from Javascript.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int float_multiply_array(float factor, float *arr, int length) {
  for (int i = 0; i &amp;lt;  length; i++) {
    arr[i] = factor * arr[i];
  }
  return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Emscripten&amp;#8217;s &lt;code&gt;cwrap&lt;/code&gt; and &lt;code&gt;ccall&lt;/code&gt; functions use only primitives to define the arguments of the ported function. Since an array (or typed array) is not a primitive type, it must be passed to the function by another mechanism – it must be passed as a number pointing to a block of memory internally managed by Emscripten.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Import function from Emscripten generated file
float_multiply_array = Module.cwrap(
  &amp;#39;float_multiply_array&amp;#39;, &amp;#39;number&amp;#39;, [&amp;#39;number&amp;#39;, &amp;#39;number&amp;#39;, &amp;#39;number&amp;#39;]
);

// Create example data to test float_multiply_array
var data = new Float32Array([1, 2, 3, 4, 5]);

// Get data byte size, allocate memory on Emscripten heap, and get pointer
var nDataBytes = data.length * data.BYTES_PER_ELEMENT;
var dataPtr = Module._malloc(nDataBytes);

// Copy data to Emscripten heap (directly accessed from Module.HEAPU8)
var dataHeap = new Uint8Array(Module.HEAPU8.buffer, ptr, nDataBytes);
dataHeap.set(new Uint8Array(data.buffer));

// Call function and get result
float_multiply_array(2, dataHeap.byteOffset, data.length);
var result = new Float32Array(dataHeap.buffer, dataHeap.byteOffset, data.length);

// Free memory
Module._free(dataHeap.byteOffset);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First the data must be copied to Emscripten&amp;#8217;s memory heap. A number representing the data&amp;#8217;s byte offset on the heap is passed as an argument to &lt;code&gt;float_multiply_array&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With these techniques, many C/C++ algorithms may be ported to Javascript, but thus far only pointers have been addressed. Many algorithms use pointers of pointers for multi-dimensional arrays (e.g. to represent an image or volume).&lt;/p&gt;

&lt;h3 id='pointers_of_pointers'&gt;Pointers of Pointers&lt;/h3&gt;

&lt;p&gt;Much of the above is described in the &lt;a href='https://github.com/kripken/emscripten/wiki/Interacting-with-code'&gt;Emscripten Wiki&lt;/a&gt;, but there isn&amp;#8217;t much discussion on pointers of pointers. Extrapolating from the above examples, consider this function, and note the use of the double pointer, &lt;code&gt;float **arr&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int float_multiply_matrix(float **arr, int ilength, int jlength) {
  float *row;
  for (int i = 0; i &amp;lt; ilength; i++) {
    row = arr[i];
    for (int j = 0; j &amp;lt; jlength; j++) {
      row[j] = 2.0 * row[j];
    }
  }
  return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Porting the function is done with &lt;code&gt;emcc&lt;/code&gt; in the same way as the previous two functions, but using this function in Javascript requires slightly more code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Import function from Emscripten generated file
var float_multiply_matrix = Module.cwrap(
  &amp;#39;float_multiply_matrix&amp;#39;, &amp;#39;number&amp;#39;, [&amp;#39;number&amp;#39;, &amp;#39;number&amp;#39;, &amp;#39;number&amp;#39;]
);

// Create example data to test float_multiply_matrix
var width = 10;
var height = 5;
var data = new Float32Array(width * height);
for (var i = 0; i &amp;lt; width * height; i++) {
  data[i] = i;
}

// Get data byte size, allocate memory on Emscripten heap, and get pointer
var nDataBytes = data.length * data.BYTES_PER_ELEMENT;
var dataPtr = Module._malloc(nDataBytes);

// Copy data to Emscripten heap
var dataHeap = new Uint8Array(Module.HEAPU8.buffer, dataPtr, nDataBytes);
dataHeap.set( new Uint8Array(data.buffer) );

// Create array of pointers that reference each row in the data
// Note the use of Uint32Array. The pointer is limited to 2147483648 bytes
// or only 2GB of memory :(
var pointers = new Uint32Array(height);
for (var i = 0; i &amp;lt; pointers.length; i++) {
  pointers[i] = dataPtr + i * data.BYTES_PER_ELEMENT * width;
}

// Allocate bytes needed for the array of pointers
var nPointerBytes = pointers.length * pointers.BYTES_PER_ELEMENT
var pointerPtr = Module._malloc(nPointerBytes);

// Copy array of pointers to Emscripten heap
var pointerHeap = new Uint8Array(Module.HEAPU8.buffer, pointerPtr, nPointerBytes);
pointerHeap.set( new Uint8Array(pointers.buffer) );

// Call the function by passing a number pointing to the byte location of 
// the array of pointers on the Emscripten heap.  Emscripten knows what to do!
float_multiply_matrix(pointerHeap.byteOffset, height, width);

var result = new Float32Array(dataHeap.buffer, dataHeap.byteOffset, data.length);

// Free memory
Module._free(pointerHeap.byteOffset);
Module._free(dataHeap.byteOffset);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The technique in the above example requires a careful preparation of data, and an understanding of byte offsets on Emscripten&amp;#8217;s heap. Emscripten offers a lot in ways of memory management making it fun to all &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; from a Javascript.&lt;/p&gt;

&lt;p&gt;The intent of using this tool is to port scientific algorithms to JS for use in web applications. Next week is &lt;a href='http://dotastronomy.com/events/five/'&gt;.astronomy&lt;/a&gt; – a conference bringing together astronomers and developers to share and implement unique ideas. One idea is to port an astronomical source extraction algorithm to Javascript. More on that soon.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Ruse In Three Dimensions</title>
   <link href="http://kapadia.github.io/visualization/2013/08/23/ruse-in-three-dimensions.html"/>
   <updated>2013-08-23T00:00:00-05:00</updated>
   <id>http://kapadia.github.io/visualization/2013/08/23/ruse-in-three-dimensions</id>
   <content type="html">&lt;p&gt;A few weeks ago I started working on a WebGL based plotting library. The software is still in its infancy, but it&amp;#8217;s beginning to show potential. Here&amp;#8217;s a &lt;a href='http://astrojs.s3.amazonaws.com/ruse/examples/three-dimension-plot.html'&gt;quick demo of Ruse plotting three dimensional data&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The primary benefit of a project like Ruse is scalability. Existing tools are cumbersome when handling larger datasets. Packages such at &lt;a href='http://matplotlib.org/'&gt;matplotlib&lt;/a&gt; render using the CPU, whereas Ruse utilizes the GPU. With most modern browsers supporting WebGL, there&amp;#8217;s no need to install OpenGL bindings to use, for instance, a Python based OpenGL plotting package.&lt;/p&gt;

&lt;p&gt;Ruse is still missing key components, like the absent axes in the above demo, but these items will be added in the next few weeks.&lt;/p&gt;

&lt;p&gt;Find &lt;a href='https://github.com/kapadia/ruse.js'&gt;&lt;code&gt;ruse.js&lt;/code&gt;&lt;/a&gt; on GitHub.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Transferring Compressed Files from S3</title>
   <link href="http://kapadia.github.io/2013/08/16/transferring-files-s3.html"/>
   <updated>2013-08-16T00:00:00-05:00</updated>
   <id>http://kapadia.github.io/2013/08/16/transferring-files-s3</id>
   <content type="html">&lt;p&gt;Requesting binary data over an &lt;code&gt;XMLHttpRequest&lt;/code&gt; (XHR) is becoming more frequent. Transferring binary data has benefits compared to sending a JSON representation when a native data format is desired or when a more compact data representation is needed compared to sending a string based format. JSON tends to work fine when file sizes are small, but if large chunks of data need to be transferred to the client, a binary representation is more compact.&lt;/p&gt;

&lt;p&gt;Amazon&amp;#8217;s S3 supports sending compressed data using gzip. This feature is often used to serve compressed javascript or css files, reducing transfer times, and utilizing the browser&amp;#8217;s implementation of DEFLATE to decompress the files. These features may also be used for arbitrary binary data, but there&amp;#8217;s a trick.&lt;/p&gt;

&lt;p&gt;All data must be gzipped prior to uploading to S3. For instance,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gzip some-binary-file&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will compress the file using gzip, substantially reducing the file size. Uploading this file to S3 requires a few flags to be set. If using &lt;code&gt;s3cmd&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s3cmd put some-binary-file.gz s3://some-s3-bucket/ --mime-type &amp;quot;application/json&amp;quot; --add-header &amp;quot;Content-Encoding: gzip&amp;quot; --acl-public&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The content encoding must be specified as &lt;code&gt;gzip&lt;/code&gt;, and the mime-type &lt;em&gt;must be&lt;/em&gt; &lt;code&gt;application/json&lt;/code&gt;, even if the file is not JSON.&lt;/p&gt;

&lt;p&gt;The binary XHR is written as,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var xhr = new XMLHttpRequest();
xhr.open(&amp;#39;GET&amp;#39;, url_to_binary_file);
xhr.responseType = &amp;#39;arraybuffer&amp;#39;;

// NOTE: Overriding the mime type from the client does not work!
// xhr.overrideMimeType(&amp;quot;application/json&amp;quot;)

xhr.onload = function() {
  console.log(xhr.response);
}
xhr.send();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the previously large file is transferred as a compressed file, but retrieved in it&amp;#8217;s original format!&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Ruse</title>
   <link href="http://kapadia.github.io/visualization/2013/08/09/ruse.html"/>
   <updated>2013-08-09T00:00:00-05:00</updated>
   <id>http://kapadia.github.io/visualization/2013/08/09/ruse</id>
   <content type="html">&lt;p&gt;For a while I&amp;#8217;ve been waiting for an in-browser plotting library built on WebGL. Though there are many great browser-based plotting solutions, the current suite of tools don&amp;#8217;t always address use cases in science.&lt;/p&gt;

&lt;p&gt;In the sciences it not uncommon to work with large datasets. For instances, the Sloan Digital Sky Survey (SDSS) just announced its 10th data release containing vast information on millions of astronomical objects, including optical spectra for 3,358,200 objects. Attempting to visualize this many points on a scatter plot would cripple many plotting libraries, and not just those constrained to the browser.&lt;/p&gt;

&lt;p&gt;Current browser libraries are built on one of two technologies, SVG or canvas. SVG based libraries offer vector based plots, allowing the graphic to resize to any dimension without losing quality. The drawback is that SVG graphics append one DOM element for every data point. Handling a large dataset such as the SDSS catalog bloats the DOM, creating a hierarchical structure that is tediously slow for the browser to parse. One idea is to move the plot to a canvas based library. Drawing on a canvas consolidates all points onto a single raster graphic represented as one DOM element. Being a raster graphic, it loses the freedom to losslessly resize, but allows for more points to be drawn. Despite scaling better than SVG, canvas suffers from performance problems due to a large number of draw calls pounding the CPU.&lt;/p&gt;

&lt;p&gt;The next step is to use newer technologies as a foundation for a new library. Modern browsers, namely Firefox and Chrome, have implemented WebGL, an API to interface with the graphics card. Whereas SVG and canvas primarily use the CPU, WebGL taps into the power of the GPU for drawing graphics. The benefit is raw speed, and scalability of the dataset size.&lt;/p&gt;

&lt;p&gt;Ruse is a new browser-based plotting library utilizing WebGL for plotting large datasets. In its current form, Ruse generates histograms and two-dimensional scatter plots. Using Ruse is simple.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Initialize a plot by passing a parent DOM element, width, and height
var ruse = new astro.Ruse(el, width, height);

// Create a histogram by passing an array of objects.
var histogramData = [{x: 9309}, {x: 23098342089}, ..., {x: 3093232}];
ruse.plot(histogramData);

// Or create a scatter plot
var scatterData = [{x: 43843, y: 440943}, {x: 3902, y:49084}, ..., {x:39032, y:329824}];
ruse.plot(scatterData);

// Ruse creates the appropriate plot by checking the dimensionality
// of the first data point in the array&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ruse has not yet gone through rigorous stress testing, but it successfully plotted the right ascension and declination of all 3,358,200 objects in the &lt;a href='http://www.sdss3.org/dr10/data_access/bulk.php'&gt;optical spectra catalog of SDSS DR10&lt;/a&gt;, confirming that SDSS &lt;em&gt;is&lt;/em&gt; a northern hemisphere optical telescope, blind along the galactic plane.&lt;/p&gt;

&lt;p&gt;Find &lt;a href='https://github.com/kapadia/ruse.js'&gt;&lt;code&gt;ruse.js&lt;/code&gt;&lt;/a&gt; and &lt;a href='https://kapadia.github.com/ruse.js'&gt;demo&lt;/a&gt; on GitHub.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>fitsjs 0.5.0</title>
   <link href="http://kapadia.github.io/astrojs/2013/07/26/fitsjs.html"/>
   <updated>2013-07-26T00:00:00-05:00</updated>
   <id>http://kapadia.github.io/astrojs/2013/07/26/fitsjs</id>
   <content type="html">&lt;p&gt;The wildly popular astronomical data format – FITS – now has an upgraded javascript library!&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fitsjs&lt;/code&gt; has been refactored to handle more real-world use cases. Originally the library was developed to read images for only Zooniverse use cases. This meant reading small SDSS and HST cutouts of around 500 pixels. Most users of FITS (pretty much just astronomers and a few folks at the Vatican Library) handle much larger files. With this refactoring, &lt;code&gt;fitsjs&lt;/code&gt; handles files of around 1 gigabyte or more in size.&lt;/p&gt;

&lt;p&gt;With the update, &lt;code&gt;fitsjs&lt;/code&gt; has improved read speeds utilizing multi-threading (via Web Workers), and has a more javascript-esque API, heavily relying on callback functions for time intensive operations.&lt;/p&gt;

&lt;p&gt;Find &lt;a href='https://github.com/astrojs/fitsjs'&gt;&lt;code&gt;fitsjs&lt;/code&gt;&lt;/a&gt; and &lt;a href='http://astrojs.github.io/fitsjs/'&gt;documentation&lt;/a&gt; on GitHub.&lt;/p&gt;

&lt;p&gt;The library is easy to use, almost like PyFITS, but with callback functions. Here&amp;#8217;s a snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Define a callback function for when the file is read
function readCallback(f) {
  
  // Get the first header
  var header1 = f.getHeader();  // or f.getHeader(0)
  
  // Get the second header if the file has multiple header-dataunits
  var header2 = f.getHeader(1);
  
  // Print a keyword from header
  console.log(header.get(&amp;#39;BITPIX&amp;#39;));
  
  // Get the first dataunit
  var dataunit1 = f.getDataUnit();
  
  // Or how about the second dataunit
  var dataunit2 = f.getDataUnit(1);
  
  // Assuming this is an image, let&amp;#39;s get the pixels (it&amp;#39;s a asynchronous process)
  dataunit1.getFrame(0, function(arr) {
    console.log(arr);
  });
}

// Initialize
var f = new astro.FITS(&amp;#39;/path/to/fits/file.fits&amp;#39;, readCallback);&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>Hola Mundo!</title>
   <link href="http://kapadia.github.io/2013/07/19/hola-mundo.html"/>
   <updated>2013-07-19T00:00:00-05:00</updated>
   <id>http://kapadia.github.io/2013/07/19/hola-mundo</id>
   <content type="html">&lt;p&gt;There will be snippets about software development, mostly related to &lt;a href='http://www.astrojs.org/'&gt;astrojs&lt;/a&gt;. Whoa.&lt;/p&gt;</content>
 </entry>
 

</feed>
