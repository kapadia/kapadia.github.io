<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Amit Kapadia</title>
 <link href="http://kapadia.github.io/atom.xml" rel="self"/>
 <link href="http://kapadia.github.io"/>
 <updated>2013-08-23T13:31:31-05:00</updated>
 <id>http://kapadia.github.io</id>
 <author>
   <name>Amit Kapadia</name>
 </author>

 
 <entry>
   <title>Ruse In Three Dimensions</title>
   <link href="http://kapadia.github.io/visualization/2013/08/23/ruse-in-three-dimensions.html"/>
   <updated>2013-08-23T00:00:00-05:00</updated>
   <id>http://kapadia.github.io/visualization/2013/08/23/ruse-in-three-dimensions</id>
   <content type="html">&lt;p&gt;A few weeks ago I started working on a WebGL based plotting library. The software is still in its infancy, but it&amp;#8217;s beginning to show potential. Here&amp;#8217;s a &lt;a href='http://astrojs.s3.amazonaws.com/ruse/examples/three-dimension-plot.html'&gt;quick demo of Ruse plotting three dimensional data&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The primary benefit of a project like Ruse is scalability. Existing tools are cumbersome when handling larger datasets. Packages such at &lt;a href='http://matplotlib.org/'&gt;matplotlib&lt;/a&gt; render using the CPU, whereas Ruse utilizes the GPU. With most modern browsers supporting WebGL, there&amp;#8217;s no need to install OpenGL bindings to use, for instance, a Python based OpenGL plotting package.&lt;/p&gt;

&lt;p&gt;Ruse is still missing key components, like the absent axes in the above demo, but these items will be added in the next few weeks.&lt;/p&gt;

&lt;p&gt;Find &lt;a href='https://github.com/kapadia/ruse.js'&gt;&lt;code&gt;ruse.js&lt;/code&gt;&lt;/a&gt; on GitHub.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Transferring Compressed Files from S3</title>
   <link href="http://kapadia.github.io/2013/08/16/transferring-files-s3.html"/>
   <updated>2013-08-16T00:00:00-05:00</updated>
   <id>http://kapadia.github.io/2013/08/16/transferring-files-s3</id>
   <content type="html">&lt;p&gt;Requesting binary data over an &lt;code&gt;XMLHttpRequest&lt;/code&gt; (XHR) is becoming more frequent. Transferring binary data has benefits compared to sending a JSON representation when a native data format is desired or when a more compact data representation is needed compared to sending a string based format. JSON tends to work fine when file sizes are small, but if large chunks of data need to be transferred to the client, a binary representation is more compact.&lt;/p&gt;

&lt;p&gt;Amazon&amp;#8217;s S3 supports sending compressed data using gzip. This feature is often used to serve compressed javascript or css files, reducing transfer times, and utilizing the browser&amp;#8217;s implementation of DEFLATE to decompress the files. These features may also be used for arbitrary binary data, but there&amp;#8217;s a trick.&lt;/p&gt;

&lt;p&gt;All data must be gzipped prior to uploading to S3. For instance,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gzip some-binary-file&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will compress the file using gzip, substantially reducing the file size. Uploading this file to S3 requires a few flags to be set. If using &lt;code&gt;s3cmd&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s3cmd put some-binary-file.gz s3://some-s3-bucket/ --mime-type &amp;quot;application/json&amp;quot; --add-header &amp;quot;Content-Encoding: gzip&amp;quot; --acl-public&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The content encoding must be specified as &lt;code&gt;gzip&lt;/code&gt;, and the mime-type &lt;em&gt;must be&lt;/em&gt; &lt;code&gt;application/json&lt;/code&gt;, even if the file is not JSON.&lt;/p&gt;

&lt;p&gt;The binary XHR is written as,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var xhr = new XMLHttpRequest();
xhr.open(&amp;#39;GET&amp;#39;, url_to_binary_file);
xhr.responseType = &amp;#39;arraybuffer&amp;#39;;

// NOTE: Overriding the mime type from the client does not work!
// xhr.overrideMimeType(&amp;quot;application/json&amp;quot;)

xhr.onload = function() {
  console.log(xhr.response);
}
xhr.send();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the previously large file is transferred as a compressed file, but retrieved in it&amp;#8217;s original format!&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Ruse</title>
   <link href="http://kapadia.github.io/visualization/2013/08/09/ruse.html"/>
   <updated>2013-08-09T00:00:00-05:00</updated>
   <id>http://kapadia.github.io/visualization/2013/08/09/ruse</id>
   <content type="html">&lt;p&gt;For a while I&amp;#8217;ve been waiting for an in-browser plotting library built on WebGL. Though there are many great browser-based plotting solutions, the current suite of tools don&amp;#8217;t always address use cases in science.&lt;/p&gt;

&lt;p&gt;In the sciences it not uncommon to work with large datasets. For instances, the Sloan Digital Sky Survey (SDSS) just announced its 10th data release containing vast information on millions of astronomical objects, including optical spectra for 3,358,200 objects. Attempting to visualize this many points on a scatter plot would cripple many plotting libraries, and not just those constrained to the browser.&lt;/p&gt;

&lt;p&gt;Current browser libraries are built on one of two technologies, SVG or canvas. SVG based libraries offer vector based plots, allowing the graphic to resize to any dimension without losing quality. The drawback is that SVG graphics append one DOM element for every data point. Handling a large dataset such as the SDSS catalog bloats the DOM, creating a hierarchical structure that is tediously slow for the browser to parse. One idea is to move the plot to a canvas based library. Drawing on a canvas consolidates all points onto a single raster graphic represented as one DOM element. Being a raster graphic, it loses the freedom to losslessly resize, but allows for more points to be drawn. Despite scaling better than SVG, canvas suffers from performance problems due to a large number of draw calls pounding the CPU.&lt;/p&gt;

&lt;p&gt;The next step is to use newer technologies as a foundation for a new library. Modern browsers, namely Firefox and Chrome, have implemented WebGL, an API to interface with the graphics card. Whereas SVG and canvas primarily use the CPU, WebGL taps into the power of the GPU for drawing graphics. The benefit is raw speed, and scalability of the dataset size.&lt;/p&gt;

&lt;p&gt;Ruse is a new browser-based plotting library utilizing WebGL for plotting large datasets. In its current form, Ruse generates histograms and two-dimensional scatter plots. Using Ruse is simple.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Initialize a plot by passing a parent DOM element, width, and height
var ruse = new astro.Ruse(el, width, height);

// Create a histogram by passing an array of objects.
var histogramData = [{x: 9309}, {x: 23098342089}, ..., {x: 3093232}];
ruse.plot(histogramData);

// Or create a scatter plot
var scatterData = [{x: 43843, y: 440943}, {x: 3902, y:49084}, ..., {x:39032, y:329824}];
ruse.plot(scatterData);

// Ruse creates the appropriate plot by checking the dimensionality
// of the first data point in the array&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ruse has not yet gone through rigorous stress testing, but it successfully plotted the right ascension and declination of all 3,358,200 objects in the &lt;a href='http://www.sdss3.org/dr10/data_access/bulk.php'&gt;optical spectra catalog of SDSS DR10&lt;/a&gt;, confirming that SDSS &lt;em&gt;is&lt;/em&gt; a northern hemisphere optical telescope, blind along the galactic plane.&lt;/p&gt;

&lt;p&gt;Find &lt;a href='https://github.com/kapadia/ruse.js'&gt;&lt;code&gt;ruse.js&lt;/code&gt;&lt;/a&gt; and &lt;a href='https://kapadia.github.com/ruse.js'&gt;demo&lt;/a&gt; on GitHub.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>fitsjs 0.5.0</title>
   <link href="http://kapadia.github.io/astrojs/2013/07/26/fitsjs.html"/>
   <updated>2013-07-26T00:00:00-05:00</updated>
   <id>http://kapadia.github.io/astrojs/2013/07/26/fitsjs</id>
   <content type="html">&lt;p&gt;The wildly popular astronomical data format – FITS – now has an upgraded javascript library!&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fitsjs&lt;/code&gt; has been refactored to handle more real-world use cases. Originally the library was developed to read images for only Zooniverse use cases. This meant reading small SDSS and HST cutouts of around 500 pixels. Most users of FITS (pretty much just astronomers and a few folks at the Vatican Library) handle much larger files. With this refactoring, &lt;code&gt;fitsjs&lt;/code&gt; handles files of around 1 gigabyte or more in size.&lt;/p&gt;

&lt;p&gt;With the update, &lt;code&gt;fitsjs&lt;/code&gt; has improved read speeds utilizing multi-threading (via Web Workers), and has a more javascript-esque API, heavily relying on callback functions for time intensive operations.&lt;/p&gt;

&lt;p&gt;Find &lt;a href='https://github.com/astrojs/fitsjs'&gt;&lt;code&gt;fitsjs&lt;/code&gt;&lt;/a&gt; and &lt;a href='http://astrojs.github.io/fitsjs/'&gt;documentation&lt;/a&gt; on GitHub.&lt;/p&gt;

&lt;p&gt;The library is easy to use, almost like PyFITS, but with callback functions. Here&amp;#8217;s a snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Define a callback function for when the file is read
function readCallback(f) {
  
  // Get the first header
  var header1 = f.getHeader();  // or f.getHeader(0)
  
  // Get the second header if the file has multiple header-dataunits
  var header2 = f.getHeader(1);
  
  // Print a keyword from header
  console.log(header.get(&amp;#39;BITPIX&amp;#39;));
  
  // Get the first dataunit
  var dataunit1 = f.getDataUnit();
  
  // Or how about the second dataunit
  var dataunit2 = f.getDataUnit(1);
  
  // Assuming this is an image, let&amp;#39;s get the pixels (it&amp;#39;s a asynchronous process)
  dataunit1.getFrame(0, function(arr) {
    console.log(arr);
  });
}

// Initialize
var f = new astro.FITS(&amp;#39;/path/to/fits/file.fits&amp;#39;, readCallback);&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>Hola Mundo!</title>
   <link href="http://kapadia.github.io/2013/07/19/hola-mundo.html"/>
   <updated>2013-07-19T00:00:00-05:00</updated>
   <id>http://kapadia.github.io/2013/07/19/hola-mundo</id>
   <content type="html">&lt;p&gt;There will be snippets about software development, mostly related to &lt;a href='http://www.astrojs.org/'&gt;astrojs&lt;/a&gt;. Whoa.&lt;/p&gt;</content>
 </entry>
 

</feed>
