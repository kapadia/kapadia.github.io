<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Emscripten: Pointers and Pointers</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

        <link href="/atom.xml" rel="alternate" title="Amit Kapadia" type="application/atom+xml" />

    </head>
    <body>

        <div class="container">
          <div class='about'>
            <img class='me' src='/images/me.jpg'>
            <div class='whoami'>
              <p class='name'>Amit Kapadia</p>
              <p>Citizen Science developer for the Zooniverse. Usually found in a planetarium or climbing a crag.</p>
              <p>
                <a href="http://github.com/kapadia/"><img src='/images/github-logo.png'></a>
                <a href="http://twitter.com/amitinho/"><img src='/images/twitter-logo.png'></a>
              </p>
            </div>
          </div>

          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">astronomy + javascript + visualization</a></h1>
            </div>

              <h2>Emscripten: Pointers and Pointers</h2>
<p class="meta">13 Sep 2013</p>

<div class="post">
<p><a href='http://emscripten.org'>Emscripten</a> is a <a href='http://www.mozilla.org/research/'>Mozilla Research</a> project that compiles LLVM bytecode to Javascript. Any language (e.g. C and C++) that compiles to LLVM as an intermediary may be ported to Javascript for use in the browser. This is a brief write up on porting functions to JS and exposing their functionality.</p>

<h3 id='c_to_javascript'>C to Javascript</h3>

<p>Porting functions from C/C++ to Javascript is straight-forward. As an example, the C function below multiplies two numbers.</p>

<pre><code>extern &quot;C&quot; {
  int float_multiply(float x, float y) {
    return x * y;
  }
}</code></pre>

<p>Running the following on the command line will port this function to Javascript outputting the code to <code>multiply.js</code>.</p>

<pre><code>emcc multiply.cpp -o multiply.js -s EXPORTED_FUNCTIONS=&quot;[&#39;_float_multiply&#39;]&quot;</code></pre>

<p>Note that the <code>EXPORTED_FUNCTIONS</code> flag specifies an array of functions to export, each with a leading underscore. If the function is not explicitly listed then Emscripten will consider it dead code, and strip it from the output.</p>

<p>After including <code>multiply.js</code> in a project, the function may be accessed by calling <code>cwrap</code> from <code>Module</code>, an object that Emscripten defines in its output. This function exposes <code>float_multiply</code> by specifying the function name, the return type, and an array of argument types.</p>

<pre><code>var float_multiply = Module.cwrap(&#39;float_multiply&#39;, &#39;number&#39;, [&#39;number&#39;, &#39;number&#39;]);
var result = float_multiply(5.2, 4.5);</code></pre>

<p>Using <code>cwrap</code> (or <code>ccall</code>) is simple when functions use only primitive types as arguments, however many interesting functions use pointers as a means to operate over an array.</p>

<h3 id='pointers'>Pointers</h3>

<p>Using pointers with a ported function needs a bit more machinery. For example, the C function below is ported using <code>emcc</code> in the same way as <code>float_multiply</code>, but it&#8217;s slightly more complex to use from Javascript.</p>

<pre><code>int float_multiply_array(float factor, float *arr, int length) {
  for (int i = 0; i &lt;  length; i++) {
    arr[i] = factor * arr[i];
  }
  return 0;
}</code></pre>

<p>Emscripten&#8217;s <code>cwrap</code> and <code>ccall</code> functions use only primitives to define the arguments of the ported function. Since an array (or typed array) is not a primitive type, it must be passed to the function by another mechanism – it must be passed as a number pointing to a block of memory internally managed by Emscripten.</p>

<pre><code>// Import function from Emscripten generated file
float_multiply_array = Module.cwrap(
  &#39;float_multiply_array&#39;, &#39;number&#39;, [&#39;number&#39;, &#39;number&#39;, &#39;number&#39;]
);

// Create example data to test float_multiply_array
var data = new Float32Array([1, 2, 3, 4, 5]);

// Get data byte size, allocate memory on Emscripten heap, and get pointer
var nDataBytes = data.length * data.BYTES_PER_ELEMENT;
var dataPtr = Module._malloc(nDataBytes);

// Copy data to Emscripten heap (directly accessed from Module.HEAPU8)
var dataHeap = new Uint8Array(Module.HEAPU8.buffer, ptr, nDataBytes);
dataHeap.set(new Uint8Array(data.buffer));

// Call function and get result
float_multiply_array(2, dataHeap.byteOffset, data.length);
var result = new Float32Array(dataHeap.buffer, dataHeap.byteOffset, data.length);

// Free memory
Module._free(dataHeap.byteOffset);</code></pre>

<p>First the data must be copied to Emscripten&#8217;s memory heap. A number representing the data&#8217;s byte offset on the heap is passed as an argument to <code>float_multiply_array</code>.</p>

<p>With these techniques, many C/C++ algorithms may be ported to Javascript, but thus far only pointers have been addressed. Many algorithms use pointers of pointers for multi-dimensional arrays (e.g. to represent an image or volume).</p>

<h3 id='pointers_of_pointers'>Pointers of Pointers</h3>

<p>Much of the above is described in the <a href='https://github.com/kripken/emscripten/wiki/Interacting-with-code'>Emscripten Wiki</a>, but there isn&#8217;t much discussion on pointers of pointers. Extrapolating from the above examples, consider this function, and note the use of the double pointer, <code>float **arr</code>.</p>

<pre><code>int float_multiply_matrix(float **arr, int ilength, int jlength) {
  float *row;
  for (int i = 0; i &lt; ilength; i++) {
    row = arr[i];
    for (int j = 0; j &lt; jlength; j++) {
      row[j] = 2.0 * row[j];
    }
  }
  return 0;
}</code></pre>

<p>Porting the function is done with <code>emcc</code> in the same way as the previous two functions, but using this function in Javascript requires slightly more code.</p>

<pre><code>// Import function from Emscripten generated file
var float_multiply_matrix = Module.cwrap(
  &#39;float_multiply_matrix&#39;, &#39;number&#39;, [&#39;number&#39;, &#39;number&#39;, &#39;number&#39;]
);

// Create example data to test float_multiply_matrix
var width = 10;
var height = 5;
var data = new Float32Array(width * height);
for (var i = 0; i &lt; width * height; i++) {
  data[i] = i;
}

// Get data byte size, allocate memory on Emscripten heap, and get pointer
var nDataBytes = data.length * data.BYTES_PER_ELEMENT;
var dataPtr = Module._malloc(nDataBytes);

// Copy data to Emscripten heap
var dataHeap = new Uint8Array(Module.HEAPU8.buffer, dataPtr, nDataBytes);
dataHeap.set( new Uint8Array(data.buffer) );

// Create array of pointers that reference each row in the data
// Note the use of Uint32Array. The pointer is limited to 2147483648 bytes
// or only 2GB of memory :(
var pointers = new Uint32Array(height);
for (var i = 0; i &lt; pointers.length; i++) {
  pointers[i] = dataPtr + i * data.BYTES_PER_ELEMENT * width;
}

// Allocate bytes needed for the array of pointers
var nPointerBytes = pointers.length * pointers.BYTES_PER_ELEMENT
var pointerPtr = Module._malloc(nPointerBytes);

// Copy array of pointers to Emscripten heap
var pointerHeap = new Uint8Array(Module.HEAPU8.buffer, pointerPtr, nPointerBytes);
pointerHeap.set( new Uint8Array(pointers.buffer) );

// Call the function by passing a number pointing to the byte location of 
// the array of pointers on the Emscripten heap.  Emscripten knows what to do!
float_multiply_matrix(pointerHeap.byteOffset, height, width);

var result = new Float32Array(dataHeap.buffer, dataHeap.byteOffset, data.length);

// Free memory
Module._free(pointerHeap.byteOffset);
Module._free(dataHeap.byteOffset);</code></pre>

<p>The technique in the above example requires a careful preparation of data, and an understanding of byte offsets on Emscripten&#8217;s heap. Emscripten offers a lot in ways of memory management making it fun to all <code>malloc</code> and <code>free</code> from a Javascript.</p>

<p>The intent of using this tool is to port scientific algorithms to JS for use in web applications. Next week is <a href='http://dotastronomy.com/events/five/'>.astronomy</a> – a conference bringing together astronomers and developers to share and implement unique ideas. One idea is to port an astronomical source extraction algorithm to Javascript. More on that soon.</p>
</div>

          </div>
        </div> <!-- /container -->

    </body>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-42541543-1', 'kapadia.github.io');
      ga('send', 'pageview');

    </script>
</html>
